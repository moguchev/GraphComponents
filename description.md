(# Описание программы

## Краткое описание логики
Статичесая функция из parth класса CFileParser отвечает за разбор входного файла и запись ребер графа в абстрактный граф, удовлетворяющий интерфейсу IGraph<T>.

У интерфеса IGraph<T> следующие методы:
- void addEdge(const T& from, const T& to) - добавление ребра от from к to
- std::list<T> getNextVertices(const T& vertex) const - возвращает всех соседей вершины vertex
- void importAllVertices( IVerticesCollection<T>& collection) const - записывает в абстрактную коллекцию вершин все вершины графа
- void importAllEdges(IEdgesCollection<T>& collection) - записывает в абстрактную коллекцию рёбер все рёбра графа

Функция showStatisticsOfWalking инкапсулирует подсчёт времени работы поиска компонент связности в графе. 
Принимает на вход граф, удовлетворяющий интерфейсу IGraph<T> и класс, удовлетворяющий интерфейсу IGraphWalker<T>, и файл куда выводить результат. Замеряет время до начала работы алгоритма поиска у класса с интерфейсом IGraphWalker<T>, Вызывает поиск компонент. По завершению поиска земеряет время и выводит время работы поиска. Затем выводит в файл найденные компоненты.

Классы с интерфейсом IGraphWalker<T> отвечают за инкапсуляцию поиск компонент в графе.
У интерфейса IGraphWalker<T> есть метод findComponentsInGraph(const IGraph<T>& graph), который возвращает указатель на класс, инкапсулирующий представление компонент графа, удовлетворяющих интерфейсу IGraphComponents<T>, в котором есть метод print() - вывод в консоль и printToFile(const std::string& filename) - вывод в файл.

Класс CListGraph<T> наследован от IGraph<T>. Реализует хранение неориентированного графа на списках смежности.

Класс CArcGraph<T> наследован от IGraph<T>. Реализует хранение неориентированного графа на списках всех рёбер.

Класс CBFSWalker<T> наследован от IGraphWalker<T>. В нём инкапсулирован обход в ширину static BFS, и поиск компонент (метод) findComponentsInGraph с помощью обхода в ширину.

Класс CDFSWalkerr<T> наследован от IGraphWalker<T>. В нём инкапсулирован обход в глубину static DFS, и поиск компонент (метод) findComponentsInGraph с помощью обхода в глубину.

Класс CBFSWalker<T> наследован от IGraphWalker<T>. В нём инкапсулирован поис компонент (метод) findComponentsInGraph с помощью системы непересекающихся множеств.

Класс CDSU<T> реализует систему непересекающихся множеств. Метод makeSet(T el) создает множество el с одним элементом el(становится представителем этог множества).
Метод findSet(T el) определяет в каком множестве находится el и возвращает представителя этого множества(если есть) или nullopt если элемента нет ни в одном из множеств.
Метод unionSets(T a, T b) объединяет два множества, в которых находятся элементы a и b, соответсвенно.

## Использованные структуры данных

Для хранения посещенных вершин в методе findComponentsInGraph класса CBFSWalker<T> использовалась хэш-таблица, так как нужен доступ к вершине и проверка посещена она или пометить посещённой за О(1).

Для хранения посещенных вершин в методе findComponentsInGraph класса CDFSWalker<T> использовалась хэш-таблица по аналогичным причинам.
Для быстрой записи обойдённых вершин в BFS и DFS элементы компоненты записваются в лист, так как вставка в лист за O(1) и не происходит переаллоцирование памяти.
Компонента(лист),полученая из DFS или BFS пушится в лист, так как вставка за O(1) и не происходит переаллоцирование памяти.
Поиск компонент возвращает указатель на компоненты связности, таким образом не происходит копирование.

В классе CDSU<T> для хранения элементов и их предка используется хэш таблица, в которой хранится элемент и его родитель, так как нужен доступ к элементу и проверки его родителя, или изменение родителя за О(1).
Почему не используется красно-черное дерево?
Мы применяем эвристику сжатых путей, при выполнении операции findSet(v), все пройденные вершины от v до представителя множества подвешиваются к представителю, в итоге у нас у одной вершины может быть много потомков, при этом нам всегда нужен доступ к элементу за O(1).
Для хранения рангов у элементов так же используется хэш таблица, чтобы менять ранг и элемента за O(1).

## Оценка сложности 

Функция findComponentsInGraph в классе CBFSWalker<T> импортирует все вершины из графа( на списках смежных вершин) за O(|V|) (|V| - число вершин в графе), так как в графе на списках смежных вершин все вершины хранятся в хэш таблице, и мы просто её обходим и записываем в выходную хэш-таблицу сметками bool у каждой вершины за О(1) каждую.
Далее запускатеся цикл по получченой таблице, если у вершины метка false( не посещена ), то запускаем обход в ширину bfs, начиная с этой вершины, если true, то итерируемся по таблице дальше.
Пусть в графе k - компонент связности, в каждой i компоненте |Ei| ребер и |Vi| вершин, причем |E1| + |E2| +...+ |Ek| = |E| и |V1| + |V2| + ... |Vk| = |V|. При обходе таблицы вершин поиск в шируну запустится k раз для каждой компоненты в итое сложность это сумма сложностей обхода каждой компоненты(тоесть сумма работы всех вызванных функций bfs), тоесть О(|E1|+ |V1| +...+|Ek|+|Vk|) = O(|E| + |V|).

Для поиска в глубину функция findComponentsInGraph в классе CDFSWalker<T> аналогично O(|E| + |V|).

Класс CDSU
Функция makeSet просто создаём дерево с корнем в вершине , отмечая, что её предок — это она сама, тоесть за O(1), так как вставка в хэш-таблицу за О(1).

Функция findSet с эвристикой сжатия путей в среднем имеет асимптоту O(logn) на 1 запрос.
Док-во
Назовём весом **w[v]** вершины **v** число потомков этой вершины (включая её саму). Веса вершин, очевидно, могут только увеличиваться в процессе работы алгоритма.
Назовём размахом ребра **(a,b)**  разность весов концов этого ребра: **|w[a] - w[b]|** (очевидно, у вершины-предка вес всегда больше, чем у вершины-потомка). Можно заметить, что размах какого-либо фиксированного ребра **(a,b)** может только увеличиваться в процессе работы алгоритма.
Кроме того, разобьём рёбра на классы: будем говорить, что ребро имеет класс **k**, если его размах принадлежит отрезку **[2^k, 2^(k+1)-1]**. Таким образом, класс ребра — это число от **0** до **logn**.
Зафиксируем теперь произвольную вершину **x** и будем следить, как меняется ребро в её предка: сначала оно отсутствует (пока вершина **x** является лидером), затем проводится ребро из **x** в какую-то вершину (когда множество с вершиной **x** присоединяется к другому множеству), и затем может меняться при сжатии путей в процессе вызовов findSet. Понятно, что нас интересует асимптотика только последнего случая (при сжатии путей): все остальные случаи требуют O(1)  времени на один запрос.
Рассмотрим работу некоторого вызова операции findSet : он проходит в дереве вдоль некоторого пути, стирая все рёбра этого пути и перенаправляя их в лидера.
Рассмотрим этот путь и исключим из рассмотрения последнее ребро каждого класса (т.е. не более чем по одному ребру из класса 0, 1, ... logn). Тем самым мы исключили O(logn) рёбер из каждого запроса.
Рассмотрим теперь все остальные рёбра этого пути. Для каждого такого ребра, если оно имеет класс , получается, что в этом пути есть ещё одно ребро класса  **k** (иначе мы были бы обязаны исключить текущее ребро, как единственного представителя класса **k**). Таким образом, после сжатия пути это ребро заменится на ребро класса как минимум **k+1**. Учитывая, что уменьшаться вес ребра не может, мы получаем, что для каждой вершины, затронутой запросом findSet, ребро в её предка либо было исключено, либо строго увеличило свой класс.
Отсюда мы окончательно получаем асимптотику работы **m** запросов: **O(n+m)logn)** что (при **m > n**) означает логарифмическое время работы на один запрос в среднем.

Функция unionSets() представляет из себя два вызова функций findSet и еще O(1) операций присвоения (Доступ к элементу хэш таблицы за О(1)), тоесть O(logn) в среднем.

Но при совместном использовании эвристие сжатия путей и ранговой эвристики время работы на один запрос findSet() получается O(a(n)), - где a(n) — обратная функция Аккермана, которая растёт очень медленно, настолько медленно, что для всех разумных ограничений n она не превосходит 4.

Именно поэтому про асимптотику работы системы непересекающихся множеств уместно говорить "почти константное время работы".

Функция findComponentsInGraph в классе CDSUWalker<T>
Импортирует все ребра графа из CArcGraph за O(|E|).
Как как каждое ребро графа СArcGraph вставляется в лист за O(1), В итоге мы O(|E|) раз произведем вставку.
Далее по полученному листу мы пробигаемся и для каждого ребра вызываем 2 раза функцию makeSet(), которые работают за O(1) и 1 раз UnionSets(), которая работает за О(а(n)).
В итоге сложность поиска O(|E|*a(n)).

## Оценка использования памяти
В обходах в ширину и в глубину мы храним хэш таблицу всех вершин графа O(|V|), и используем алгоритмы обхода которые по памяти занимают в сумме O(|V|+|E|).
Следовательно O(|V|+|E|).

В поиске основанном на dsu в функции findComponentsInGraph класса CDSUWalker<T>, нам требуется хранить все ребра в листе: O(|E|). и саму система DSU, в котрой внутри хранятся только вершины в хэш-таблице, тоесть O(|V|).
В итоге O(|V|+|E|). 
