# Описание программы

## Краткое описание логики
Статичесая функция из parth класса CFileParser отвечает за разбор входного файла и запись ребер графа в абстрактный граф, удовлетворяющий интерфейсу IGraph<T>.

У интерфеса IGraph<T> следующие методы:
- void addEdge(const T& from, const T& to) - добавление ребра от from к to
- std::list<T> getNextVertices(const T& vertex) const - возвращает всех соседей вершины vertex
- void importAllVertices( IVerticesCollection<T>& collection) const - записывает в абстрактную коллекцию вершин все вершины графа
- void importAllEdges(IEdgesCollection<T>& collection) - записывает в абстрактную коллекцию рёбер все рёбра графа

Функция showStatisticsOfWalking инкапсулирует подсчёт времени работы поиска компонент связности в графе. 
Принимает на вход граф, удовлетворяющий интерфейсу IGraph<T> и класс, удовлетворяющий интерфейсу IGraphWalker<T>, и файл куда выводить результат. Замеряет время до начала работы алгоритма поиска у класса с интерфейсом IGraphWalker<T>, Вызывает поиск компонент. По завершению поиска земеряет время и выводит время работы поиска. Затем выводит в файл найденные компоненты.

Классы с интерфейсом IGraphWalker<T> отвечают за инкапсуляцию поиск компонент в графе.
У интерфейса IGraphWalker<T> есть метод findComponentsInGraph(const IGraph<T>& graph), который возвращает указатель на класс, инкапсулирующий представление компонент графа, удовлетворяющих интерфейсу IGraphComponents<T>, в котором есть метод print() - вывод в консоль и printToFile(const std::string& filename) - вывод в файл.

Класс CListGraph<T> наследован от IGraph<T>. Реализует хранение неориентированного графа на списках смежности.

Класс CArcGraph<T> наследован от IGraph<T>. Реализует хранение неориентированного графа на списках всех рёбер.

Класс CBFSWalker<T> наследован от IGraphWalker<T>. В нём инкапсулирован обход в ширину static BFS, и поиск компонент (метод) findComponentsInGraph с помощью обхода в ширину.

Класс CDFSWalkerr<T> наследован от IGraphWalker<T>. В нём инкапсулирован обход в глубину static DFS, и поиск компонент (метод) findComponentsInGraph с помощью обхода в глубину.

Класс CBFSWalker<T> наследован от IGraphWalker<T>. В нём инкапсулирован поис компонент (метод) findComponentsInGraph с помощью системы непересекающихся множеств.

Класс CDSU<T> реализует систему непересекающихся множеств. Метод makeSet(T el) создает множество el с одним элементом el(становится представителем этог множества).
Метод findSet(T el) определяет в каком множестве находится el и возвращает представителя этого множества(если есть) или nullopt если элемента нет ни в одном из множеств.
Метод unionSets(T a, T b) объединяет два множества, в которых находятся элементы a и b, соответсвенно.

## Использованные структуры данных

Для хранения посещенных вершин в методе findComponentsInGraph класса CBFSWalker<T> использовалась хэш-таблица, так как нужен доступ к вершине и проверка посещена она или пометить посещённой за О(1).

Для хранения посещенных вершин в методе findComponentsInGraph класса CDFSWalker<T> использовалась хэш-таблица по аналогичным причинам.
Для быстрой записи обойдённых вершин в BFS и DFS элементы компоненты записваются в лист, так как вставка в лист за O(1) и не происходит переаллоцирование памяти.
Компонента(лист),полученая из DFS или BFS пушится в лист, так как вставка за O(1) и не происходит переаллоцирование памяти.
Поиск компонент возвращает указатель на компоненты связности, таким образом не происходит копирование.

В классе CDSU<T> для хранения элементов и их предка используется хэш таблица, в которой хранится элемент и его родитель, так как нужен доступ к элементу и проверки его родителя, или изменение родителя за О(1).
Мы применяем эвристику сжатых путей, при выполнении операции findSet(v), все пройденные вершины от v до представителя множества подвешиваются к представителю, в итоге у нас у одной вершины может быть много потомков, при этом нам всегда нужен доступ к элементу за O(1).
Для хранения рангов у элементов так же используется хэш таблица, чтобы менять ранг и элемента за O(1).

Для хранения графов использовалось 2 представления графа: смежные вершины и список рёбер.
Граф смежных вершин реализован на хэш-таблице где ключ - вершина, а значение - список соседних вершин. Это представление графа использовалось для быстрого получения всех вершин графа для поиска компонент с помощью линейного поиска.
Граф со списком рёбер реализован на односвязном списке, который хранит ребро: std::pair<T,T>, где T - вершина. Это представление графа использовалось для быстрого получения всех рёбер графа для поиска компонент связности с помощью системы непересекающихся множеств.

## Оценка сложности 

Функция findComponentsInGraph в классе CBFSWalker<T> импортирует все вершины из графа( на списках смежных вершин) за O(|V|) (|V| - число вершин в графе), так как в графе на списках смежных вершин все вершины хранятся в хэш таблице, и мы просто её обходим и записываем в выходную хэш-таблицу сметками bool у каждой вершины за О(1) каждую.
Далее запускатеся цикл по получченой таблице, если у вершины метка false( не посещена ), то запускаем обход в ширину bfs, начиная с этой вершины, если true, то итерируемся по таблице дальше.
Пусть в графе k - компонент связности, в каждой i компоненте |Ei| ребер и |Vi| вершин, причем |E1| + |E2| +...+ |Ek| = |E| и |V1| + |V2| + ... |Vk| = |V|. При обходе таблицы вершин поиск в шируну запустится k раз для каждой компоненты в итое сложность это сумма сложностей обхода каждой компоненты(тоесть сумма работы всех вызванных функций bfs), тоесть О(|E1|+ |V1| +...+|Ek|+|Vk|) = O(|E| + |V|).

Для поиска в глубину функция findComponentsInGraph в классе CDFSWalker<T> аналогично O(|E| + |V|).

Класс CDSU
Функция makeSet просто создаём дерево с корнем в вершине , отмечая, что её предок — это она сама, тоесть за O(1), так как вставка в хэш-таблицу за О(1).

Функция findSet с эвристикой сжатия работает в среднем а(n), где a - функция, обратная функция Аккермана.

Функция unionSets() представляет из себя два вызова функций findSet и еще O(1) операций присвоения (Доступ к элементу хэш таблицы за О(1)), тоесть O(a(n)) в среднем.

Обратная функция Аккермана растёт очень медленно, настолько медленно, что для всех разумных ограничений n она не превосходит 4.
Именно поэтому про асимптотику работы системы непересекающихся множеств уместно говорить "почти константное время работы".

Функция findComponentsInGraph в классе CDSUWalker<T>
Импортирует все ребра графа из CArcGraph за O(|E|).
Как как каждое ребро графа СArcGraph вставляется в лист за O(1), В итоге мы O(|E|) раз произведем вставку.
Далее по полученному листу мы пробигаемся и для каждого ребра вызываем 2 раза функцию makeSet(), которые работают за O(1) и 1 раз UnionSets(), которая работает за О(а(n)).
В итоге сложность поиска O(|E|*a(n)).

## Оценка использования памяти
В поиске компонент с помощью обходах в ширину и в глубину(методы findComponentsInGraph в классе CDFSWalker<T> и в классе CBFSWalker<T>) мы храним хэш таблицу всех вершин графа O(|V|) для того чтобы знать какие уже были посещены, и используем алгоритмы обхода в ширину(в глубину в классе CDFSWalker<T>) , которые хранят соседей текущей вершины и посещенные. Сложность по памяти каждого i-ого вызова обхода равно O(|Vi|), где Vi - все вершины i-ой компоненты. Сумма всех вызовов обходов по памяти занимает O(|V|) .
Следовательно сложность по памяти findComponentsInGraph в классе CDFSWalker<T> и в классе CBFSWalker<T> O(|V|).

В поиске основанном на dsu в функции findComponentsInGraph класса CDSUWalker<T>, нам требуется хранить все ребра в листе: O(|E|). и саму система DSU, в котрой внутри хранятся только вершины в хэш-таблице, тоесть O(|V|).
В итоге O(|V|+|E|). 
